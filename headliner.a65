;
; Screen Headliner was originally a program from Compute!'s 
; Gazette, which allows you to draw PETSCII characters at four 
; times the regular size, using the PETSCII quadrant characters.
;
; This version has the following improvements:
;  * More compact so that the PETSCII quadrant table can be
;    stored contiguously -- the original version required
;    an extra READ loop.
;  * Controls the cursor position and RVS state by manipulating
;    the OS variables instead of outputting control codes.
;  * Can print against the right edge of the screen without
;    breaking up the character.
; 

    processor 6502

.CHROUT        = $FFD2

; zero-page variables
FONTPAGE = $04
FONTADDR = $03
TOPROW   = $05  ; bits from even-numbered character byte
BOTROW   = $06  ; bits from odd-numbered character byte

; array to store the 16 petscii characters to write
PIXELS   = $0230

; PETSCII constants
CR         = $0D
; OS locations for manipulating output
RVS        = $C7
COLUMN     = $D3

; parameters
; starting X-position of character
XPOS       = $F9
; screen code of character to draw
CHAR       = $FA
; this is reused as the index in the final loop

; default origin.
        IFNCONST ORIGIN
ORIGIN     = $033C
        ENDIF

        ORG ORIGIN

            LDA $D018  ; get displayed font from VIC
            AND #$02
            LSR
            ADC #$D0 >> 3
            LDX #$03
.hc363:
            ASL CHAR
            ROL
            DEX
            BNE .hc363
            STA FONTPAGE
            LDA CHAR
            STA FONTADDR
            ; disable interrupts and map CHARGEN into CPU memory
            LDA $DC0E
            AND #$FE
            STA $DC0E
            LDA $01
            AND #$FB  ; set $D000 to character set ROM
            STA $01
            ; copy ROM into RAM while rearranging bits.
            LDY #$00
            STY CHAR
            ; assert Y=0 whenever branched here
SETPIXELS:  ; read two rows of pixels from ROM
            LDA (FONTADDR),Y
            STA TOPROW
            INC FONTADDR
            LDA (FONTADDR),Y
            STA BOTROW
            INC FONTADDR
            LDY #$04
GETPIXELS:  ; rearrange into four sets of 2x2 pixels
            LDA #$00
            ASL BOTROW
            ROL
            ASL BOTROW
            ROL
            ASL TOPROW
            ROL
            ASL TOPROW
            ROL
            LDX CHAR
            STA PIXELS,X
            INC CHAR
            DEY
            BNE GETPIXELS  ; else Y=0 for next branch
            CPX #15 ; use pre-incremented CHAR to see if we're done
            BNE SETPIXELS ;  restart loop, Y=0
ENABLEROM:
            LDA $01
            ORA #$04 ; map I/O to $D000
            STA $01
            LDA $DC0E
            ORA #$01 ; timer underflow on port B bit 6?
            STA $DC0E
            LDY #$00
.MOVERIGHT:
            LDX XPOS
            STX COLUMN
PUTPIXELS:
            LDA PIXELS,Y
            TAX
            LDA QUADRANTS,X
            AND #$40
            STA RVS
            EOR QUADRANTS,X
            JSR .CHROUT
            INY
            ; test for multiples of 4
            TYA
            AND #3
            BNE PUTPIXELS
            ; every 4 characters, move to next row
            LDA XPOS
            CMP #36  ; printing at right edge of screen?
            BMI DOCR
	    ; toggle between 36 and 76 each printed row
	    EOR #104
	    STA XPOS
	    BNE NOCR
DOCR
            LDA #CR
            JSR .CHROUT
NOCR
            CPY #$10
            BNE .MOVERIGHT
          RTS

;
; PETSCII characters representing the pixel graphic
; characters.  Bit $40 is a flag for whether to turn
; reverse on for this character, and is filtered out.
;
QUADRANTS
             ;hex   ; petscii      upper  lower
        byte $20    ;     SPACE      00    00
        byte $bc    ;     C= C       01    00
        byte $be    ;     C= V       10    00
        byte $e2    ; RVS C= I       11    00
        byte $ac    ;     C= D       00    01
        byte $e1    ; RVS C= K       01    01
        byte $bf    ;     C= B       10    01
        byte $fb    ; RVS C= F       11    01
        byte $bb    ;     C= F       00    10
        byte $ff    ; RVS C= B       01    10
        byte $a1    ;     C= K       10    10
        byte $ec    ; RVS C= D       11    10
        byte $a2    ;     C= I       00    11
        byte $fe    ; RVS C= V       01    11
        byte $fc    ; RVS C= C       10    11
        byte $60    ; RVS SPACE      11    11


